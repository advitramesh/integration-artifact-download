@Library('piper-lib-os') _

// Define the GitHub repository URL and branch as global variables
def repoUrl = 'github.com/advitramesh/cpi-dev'
def branchName = 'main'
def gitCredentialsId = '613fd18c-2469-433c-bca6-22c48b4eb948'

node() {
    environment {
        GITHUB_APP_CREDENTIAL = credentials(gitCredentialsId)
        configOptions = ''
    }

    stage('Prepare') {
        checkout scm
        setupCommonPipelineEnvironment script: this
    }

    // Clone the GitHub Repository
    stage('Clone GitHub Repo') {
        dir('gitRepo') {
            withCredentials([usernamePassword(credentialsId: gitCredentialsId, passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {
                // Use the credentials to clone
                sh "git clone -b ${branchName} https://${GIT_USERNAME}:${GIT_PASSWORD}@${repoUrl} ."
            }
        }
    }

    stage('Initialize') {
        deleteDir()
        checkout scm
    }

    stage('Pipeline') {
        script {
            def config = readYaml file: 'projectPiper/.pipeline/configArtifacts.yml'
            for (def step in config.steps) {
                def configOptions = [
                    cpiApiServiceKeyCredentialsId: step.cpiApiServiceKeyCredentialsId,
                    integrationFlowId: step.integrationFlowId,
                    integrationFlowVersion: step.integrationFlowVersion,
                    downloadPath: step.downloadPath
                ]

                echo "Config Options: ${configOptions}"
                stage('IntegrationArtifactDownload Command') {
                    integrationArtifactDownload(configOptions)
                }

                def packageId = step.packageId 
                
                stage('Unzip iFlows') {
                    def zipFolder = configOptions.downloadPath
                    def destinationDir = "/var/lib/jenkins/workspace/IntegrationContent/${packageId}/${integrationFlowId}"
                    sh "mkdir -p ${destinationDir}"
                    dir(zipFolder) {
                        def zipFiles = sh(script: "ls *.zip", returnStdout: true).trim().split('\n')
                        zipFiles.each { zipFileName ->
                            def zipFilePath = "${zipFolder}/${zipFileName}"
                            echo "Unzipping ${zipFilePath} to ${destinationDir}"
                            unzip zipFile: zipFilePath, dir: destinationDir
                            sh "rm -f ${zipFilePath}"
                        }
                    }
                }

                stage('Copy iFlows to Git Repo') {
                    dir('gitRepo') {
                        sh "cp -r /var/lib/jenkins/workspace/IntegrationContent/${packageId}/${integrationFlowId}/* ."
                    }
                }

                stage('Stage the changes for commit') {
                 dir('gitRepo') {
                            // Configure user for this repository
                            sh 'git config user.email "advit.ramesh@accenture.com"'
                            sh 'git config user.name "advitramesh"'
                    
                            // Stage any changes
                            sh "git add ."
                    
                            // Commit if there are any changes
                            sh 'git diff-index --quiet HEAD || git commit -am "Commit integration content updates"'
                    
                            withCredentials([usernamePassword(credentialsId: gitCredentialsId, passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {
                                // Fetch the branch
                                sh "git fetch origin ${branchName}"
                    
                                // Check if the branch exists on the remote
                                def remoteBranchExists = sh(script: "git ls-remote --heads origin ${branchName}", returnStdout: true).trim()
                    
                                // Create the branch on the remote if it doesn't exist
                                if (remoteBranchExists.isEmpty()) {
                                    sh "git push --set-upstream origin ${branchName}"
                                } else {
                                    // Check out the branch locally
                                    sh "git checkout ${branchName}"
                    
                                    // Merge changes from the remote branch, use --ff-only to avoid merging divergent branches
                                    sh "git merge --ff-only origin/${branchName}"
                                }
                    
                                // Push changes, no need to force if we're just adding new commits on top
                                sh "git push origin ${branchName}"
                            }
                        }
                    }

            }
        }
    }
}
