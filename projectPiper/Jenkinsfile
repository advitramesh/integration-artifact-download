@Library('piper-lib-os') _

// Define the GitHub repository URL and branch as global variables
def repoUrl = 'github.com/advitramesh/cpi-dev'
def branchName = 'main'
def gitCredentialsId = '613fd18c-2469-433c-bca6-22c48b4eb948'

node() {
    environment {
        GITHUB_APP_CREDENTIAL = credentials(gitCredentialsId)
        configOptions = ''
    }

    stage('Prepare') {
        checkout scm
        setupCommonPipelineEnvironment script: this
    }

    // Clone the GitHub Repository
    stage('Clone GitHub Repo') {
        dir('gitRepo') {
            withCredentials([usernamePassword(credentialsId: gitCredentialsId, passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {
                // Use the credentials to clone
                sh "git clone -b ${branchName} https://${GIT_USERNAME}:${GIT_PASSWORD}@${repoUrl} ."
            }
        }
    }

    stage('Initialize') {
        deleteDir()
        checkout scm
    }

    stage('Pipeline') {
        script {
            def config = readYaml file: 'projectPiper/.pipeline/configArtifacts.yml'
            for (def step in config.steps) {
                def configOptions = [
                    cpiApiServiceKeyCredentialsId: step.cpiApiServiceKeyCredentialsId,
                    integrationFlowId: step.integrationFlowId,
                    integrationFlowVersion: step.integrationFlowVersion,
                    downloadPath: step.downloadPath
                ]

                echo "Config Options: ${configOptions}"
                stage('IntegrationArtifactDownload Command') {
                    integrationArtifactDownload(configOptions)
                }

                def packageId = step.packageId 
                
                stage('Unzip iFlows') {
                    def zipFolder = configOptions.downloadPath
                    def destinationDir = "/var/lib/jenkins/workspace/IntegrationContent/${packageId}/${integrationFlowId}"
                    sh "mkdir -p ${destinationDir}"
                    dir(zipFolder) {
                        def zipFiles = sh(script: "ls *.zip", returnStdout: true).trim().split('\n')
                        zipFiles.each { zipFileName ->
                            def zipFilePath = "${zipFolder}/${zipFileName}"
                            echo "Unzipping ${zipFilePath} to ${destinationDir}"
                            unzip zipFile: zipFilePath, dir: destinationDir
                            sh "rm -f ${zipFilePath}"
                        }
                    }
                }

                stage('Copy iFlows to Git Repo') {
                    dir('gitRepo') {
                        sh "cp -r /var/lib/jenkins/workspace/IntegrationContent/${packageId}/${integrationFlowId}/* ."
                    }
                }

                stage('Stage the changes for commit') {
                 dir('gitRepo') {
                            // Configure user for this repository
                            sh 'git config user.email "advit.ramesh@accenture.com"'
                            sh 'git config user.name "advitramesh"'
                    
                            // Stage any changes
                            sh "git add ."
                    
                            // Commit if there are any changes
                            sh 'git diff-index --quiet HEAD || git commit -am "Commit integration content updates"'
                    
                            withCredentials([usernamePassword(credentialsId: gitCredentialsId, passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {
                                    // Fetch all information from the origin to ensure we have all the necessary data.
                                    sh "git fetch origin"
                            
                                    // Check if the 'main' branch exists on the remote and switch to it.
                                    // The 'git rev-parse --verify' command returns 0 if the branch exists, or 128 if it does not.
                                    def mainBranchExists = sh(script: "git rev-parse --verify origin/main", returnStatus: true) == 0
                                    if (mainBranchExists) {
                                        // If main branch exists remotely, check it out and reset our local main to match the remote main branch
                                        sh "git checkout -B main origin/main"
                                    } else {
                                        // If the main branch does not exist remotely, create it locally
                                        sh "git checkout -b main"
                                    }
                                
                                    // Add and commit changes, ensuring there's something to commit.
                                    sh "git add ."
                                    sh 'git diff-index --quiet HEAD || git commit -am "Commit integration content updates"'
                                
                                    // Now push the main branch back to origin, setting the upstream if it's a new branch.
                                    if (!mainBranchExists) {
                                        sh "git push --set-upstream origin main"
                                    } else {
                                        sh "git push origin main"
                                    }
                                }
                            }
                        }
                    }

            }
        }
    }
}
